
// buffer for storing subdocuments 
const pastedNoteBuffer = []

// Extract the note elements from the html so they don't get
// parsed inline by DOMParser.parseSlice() during a cut and paste
export function transformPastedHTMLHandler( teiSchema ) {
    return (html) => {
        // Meta element generated by ProseMirror isn't closed, remove it 
        // so we can parse as XML. Put it back at the end.
        const metaRegex = /(<meta [^>]*>)/
        const matches = html.match(metaRegex)
        let metaTag = matches && matches[1] ? matches[1]: ""
        let xml = html.replace(metaRegex,"")
        const parser = new DOMParser();
        // xml might be an array of elements, need to wrap them to form a valid document
        const xmlDom = parser.parseFromString(`<xml>${xml}</xml>`,'text/xml');

        let noteEls = xmlDom.getElementsByTagName('note');
        for( let i=0; i< noteEls.length; i++ ) {
            const el = noteEls[i]
            const noteID = teiSchema.issueSubDocumentID()
            const noteEl = el.cloneNode(true)
            noteEl.setAttribute('__id__',noteID)
            const emptyEl = el.cloneNode()
            emptyEl.setAttribute('__id__',noteID)
            // blank is necessary so that serializer doesn't collapse element
            emptyEl.innerHTML = ' '
            el.parentNode.replaceChild(emptyEl,el)
            pastedNoteBuffer.push(noteEl)
        }

        let xhtml = new XMLSerializer().serializeToString(xmlDom);
        xhtml = xhtml.replace('<xml>','').replace('</xml>','')
        const nextHTML = `${metaTag}${xhtml}`
        return nextHTML
    }
}

export function transformPastedHandler(teiSchema) {
    return (slice) => {
        // apply notes after DOMParse.parseSlice()
        while( pastedNoteBuffer.length > 0 ) {
            const noteEl = pastedNoteBuffer.pop()
            teiSchema.parseSubDocument(noteEl,noteEl.getAttribute('__id__'))
        }
        return slice
    }
}