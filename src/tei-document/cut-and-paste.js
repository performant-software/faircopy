import {DOMSerializer} from "prosemirror-model"
import TEISchema from "../tei-document/TEISchema"

const fairCopy = window.fairCopy

// buffer for storing subdocuments 
const pastedNoteBuffer = []

// Note about Cut and Paste:
// When the users focus is on the EditorGutter, the cut and paste handlers defined here (cutSelectedNode) are operative.
// When ProseMirror has focus, the ProseMirror editor view callbacks defined below are operative.

// Extract the note elements from the html so they don't get
// parsed inline by DOMParser.parseSlice() during a cut and paste
export function transformPastedHTMLHandler( teiSchema, teiDocument ) {
    return (html) => {
        // Meta element generated by ProseMirror isn't closed, remove it 
        // so we can parse as XML. Put it back at the end.
        const metaRegex = /(<meta [^>]*>)/
        const matches = html.match(metaRegex)
        const parser = new DOMParser();
        let metaTag = matches && matches[1] ? matches[1]: ""
        // also, replace all the non breaking spaces w/spaces, since &nbsp; isn't in schema
        let xml = html.replace(metaRegex,"").replaceAll('&nbsp;',' ')
        // detect if this is an internal cut and paste
        if( xml.includes('data-pm-slice') ) {
            // xml might be an array of elements, need to wrap them to form a valid document
            const xmlDom = parser.parseFromString(`<xml>${xml}</xml>`,'text/xml');
    
            let noteEls = xmlDom.getElementsByTagName('note');
            for( let i=0; i< noteEls.length; i++ ) {
                const el = noteEls[i]
                const noteID = teiDocument.issueSubDocumentID()
                const noteEl = el.cloneNode(true)
                noteEl.setAttribute('__id__',noteID)
                const emptyEl = el.cloneNode()
                emptyEl.setAttribute('__id__',noteID)
                el.parentNode.replaceChild(emptyEl,el)
                pastedNoteBuffer.push(noteEl)
            }

            // HTML doesn't have self closing elements, so preserve them here with this hack
            const inlines = teiSchema.elementGroups.inlines
            for( const inline of inlines ) {
                let inlineEls = xmlDom.getElementsByTagName(inline)
                for( let i=0; i < inlineEls.length; i++ ) {
                    const inlineEl = inlineEls[i]
                    // blank is necessary so that serializer doesn't collapse element
                    inlineEl.innerHTML = ' '
                }    
            }
    
            // schema needs access to this document while running parseSlice()
            // pops off in transformPastedHandler()
            teiSchema.teiDocuments.push(teiDocument)
            let xhtml = new XMLSerializer().serializeToString(xmlDom);
            xhtml = xhtml.replace('<xml>','').replace('</xml>','')
            const nextHTML = `${metaTag}${xhtml}`
            return nextHTML
        } else {
            // this is from an external source, drop markup
            const xmlDom = parser.parseFromString(xml,'text/html');
            const nextHTML = `<html><head>${metaTag}</head><body>${xmlDom.documentElement.textContent}</body></html>`
            return nextHTML
        }
    }
}

export function transformPastedHandler(teiSchema,teiDocument) {
    return (slice) => {
        // apply notes after DOMParse.parseSlice()
        while( pastedNoteBuffer.length > 0 ) {
            const noteEl = pastedNoteBuffer.pop()
            teiDocument.parseSubDocument(noteEl,noteEl.nodeName,noteEl.getAttribute('__id__'))
        }
        
        // done parsing, disassociate this teidocument from schema parser
        teiSchema.teiDocuments.pop()
        return slice
    }
}

export function createClipboardSerializer(teiSchema,teiDocument) {
    // clipboard serialize always serializes to TEI XML
    const clipboardSchema = new TEISchema(teiSchema.schemaJSON);

    // the clipboard schema is always associated with this one document and
    // is always in teiMode
    clipboardSchema.teiMode = true
    clipboardSchema.teiDocuments.push(teiDocument)
    return DOMSerializer.fromSchema( clipboardSchema.schema )    
}

export function cutSelectedNode(teiDocument) {
    copyNode(teiDocument,true)
}

export function copySelectedNode(teiDocument) {
    copyNode(teiDocument)
}

// This function is from https://github.com/ProseMirror/prosemirror-view/blob/master/src/clipboard.js
// slightly modified for this context.
function serializeForClipboard(view, slice) {
    let context = [], {content, openStart, openEnd} = slice
    while (openStart > 1 && openEnd > 1 && content.childCount === 1 && content.firstChild.childCount === 1) {
      openStart--
      openEnd--
      let node = content.firstChild
      context.push(node.type.name, node.attrs !== node.type.defaultAttrs ? node.attrs : null)
      content = node.content
    }
  
    let serializer = view.someProp("clipboardSerializer") || DOMSerializer.fromSchema(view.state.schema)
    let doc = document, wrap = doc.createElement("div")
    wrap.appendChild(serializer.serializeFragment(content, {document: doc}))
  
    let firstChild = wrap.firstChild

    if (firstChild && firstChild.nodeType === 1)
      firstChild.setAttribute("data-pm-slice", `${openStart} ${openEnd} ${JSON.stringify(context)}`)
  
    let text = view.someProp("clipboardTextSerializer", f => f(slice)) ||
        slice.content.textBetween(0, slice.content.size, "\n\n")
  
    return {dom: wrap, text}
}

function copyNode(teiDocument,cut=false) {
    const editorView = teiDocument.getActiveView()
    const {inlines} = teiDocument.fairCopyProject.teiSchema.elementGroups
    const selection = (editorView) ? editorView.state.selection : null  
    
    if( selection && selection.node && !inlines.includes(selection.node.type.name)  ) {
        const clips = serializeForClipboard(editorView,selection.content())
        fairCopy.services.copyToClipBoardHTML(clips.dom.innerHTML)
        if( cut ) {
            const {tr} = editorView.state
            tr.deleteSelection()
            editorView.dispatch(tr)    
        }
    }
}

// Handle paste events when the node is selected via the EditorGutter
export function pasteSelectedNode(teiDocument) {
    const html = fairCopy.services.readClipBoardHTML()    
    if( html ) {
        const editorView = teiDocument.getActiveView()
        const {inlines} = teiDocument.fairCopyProject.teiSchema.elementGroups
        const selection = (editorView) ? editorView.state.selection : null  
        if( selection && selection.node && !inlines.includes(selection.node.type.name)  ) {
            // make the paste happen in the editor view
            editorView.focus()
            fairCopy.services.ipcSend('requestPaste')
        }
    }
}